
;  Copyright (c) 1991-2002, The Numerical Algorithms Group Ltd.
;  All rights reserved.
;  
;  Redistribution and use in source and binary forms, with or without
;  modification, are permitted provided that the following conditions are
;  met:
;  
;      - Redistributions of source code must retain the above copyright
;        notice, this list of conditions and the following disclaimer.
;  
;      - Redistributions in binary form must reproduce the above copyright
;        notice, this list of conditions and the following disclaimer in
;        the documentation and/or other materials provided with the
;        distribution.
;  
;      - Neither the name of The Numerical ALgorithms Group Ltd. nor the
;        names of its contributors may be used to endorse or promote products
;        derived from this software without specific prior written permission.
;  
;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
;  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
;  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
;  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
;  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
;  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
;  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES-- LOSS OF USE, DATA, OR
;  PROFITS-- OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

(IN-PACKAGE (QUOTE BOOTTRAN))
(DEFUN |bpFirstToken| NIL (PROG NIL (DECLARE (SPECIAL |$ttok| |$stok| |$inputStream|)) (RETURN (PROGN (SETQ |$stok| (COND ((NULL |$inputStream|) (|shoeTokConstruct| (QUOTE ERROR) (QUOTE NOMORE) (|shoeTokPosn| |$stok|))) ((QUOTE T) (CAR |$inputStream|)))) (SETQ |$ttok| (|shoeTokPart| |$stok|)) T))))
(DEFUN |bpFirstTok| NIL (PROG NIL (DECLARE (SPECIAL |$bpCount| |$bpParenCount| |$ttok| |$stok| |$inputStream|)) (RETURN (PROGN (SETQ |$stok| (COND ((NULL |$inputStream|) (|shoeTokConstruct| (QUOTE ERROR) (QUOTE NOMORE) (|shoeTokPosn| |$stok|))) ((QUOTE T) (CAR |$inputStream|)))) (SETQ |$ttok| (|shoeTokPart| |$stok|)) (COND ((AND (< 0 |$bpParenCount|) (EQCAR |$stok| (QUOTE KEY))) (COND ((EQ |$ttok| (QUOTE SETTAB)) (PROGN (SETQ |$bpCount| (+ |$bpCount| 1)) (|bpNext|))) ((EQ |$ttok| (QUOTE BACKTAB)) (PROGN (SETQ |$bpCount| (- |$bpCount| 1)) (|bpNext|))) ((EQ |$ttok| (QUOTE BACKSET)) (|bpNext|)) (#0=(QUOTE T) T))) (#0# T))))))
(DEFUN |bpNext| NIL (PROG NIL (DECLARE (SPECIAL |$inputStream|)) (RETURN (PROGN (SETQ |$inputStream| (CDR |$inputStream|)) (|bpFirstTok|)))))
(DEFUN |bpNextToken| NIL (PROG NIL (DECLARE (SPECIAL |$inputStream|)) (RETURN (PROGN (SETQ |$inputStream| (CDR |$inputStream|)) (|bpFirstToken|)))))
(DEFUN |bpState| NIL (PROG NIL (DECLARE (SPECIAL |$bpCount| |$bpParenCount| |$stack| |$inputStream|)) (RETURN (LIST |$inputStream| |$stack| |$bpParenCount| |$bpCount|))))
(DEFUN |bpRestore| (|x|) (PROG NIL (DECLARE (SPECIAL |$bpCount| |$bpParenCount| |$stack| |$inputStream|)) (RETURN (PROGN (SETQ |$inputStream| (CAR |x|)) (|bpFirstToken|) (SETQ |$stack| (CADR |x|)) (SETQ |$bpParenCount| (CADDR |x|)) (SETQ |$bpCount| (CADDDR |x|)) T))))
(DEFUN |bpPush| (|x|) (PROG NIL (DECLARE (SPECIAL |$stack|)) (RETURN (SETQ |$stack| (CONS |x| |$stack|)))))
(DEFUN |bpPushId| NIL (PROG NIL (DECLARE (SPECIAL |$stack| |$ttok|)) (RETURN (SETQ |$stack| (CONS (|bfReName| |$ttok|) |$stack|)))))
(DEFUN |bpPop1| NIL (PROG (|a|) (DECLARE (SPECIAL |$stack|)) (RETURN (PROGN (SETQ |a| (CAR |$stack|)) (SETQ |$stack| (CDR |$stack|)) |a|))))
(DEFUN |bpPop2| NIL (PROG (|a|) (DECLARE (SPECIAL |$stack|)) (RETURN (PROGN (SETQ |a| (CADR |$stack|)) (RPLACD |$stack| (CDDR |$stack|)) |a|))))
(DEFUN |bpPop3| NIL (PROG (|a|) (DECLARE (SPECIAL |$stack|)) (RETURN (PROGN (SETQ |a| (CADDR |$stack|)) (RPLACD (CDR |$stack|) (CDDDR |$stack|)) |a|))))
(DEFUN |bpIndentParenthesized| (|f|) (PROG (|$bpCount| |a|) (DECLARE (SPECIAL |$inputStream| |$bpCount| |$bpParenCount| |$stok|)) (RETURN (PROGN (SETQ |$bpCount| 0) (SETQ |a| |$stok|) (COND ((|bpEqPeek| (QUOTE OPAREN)) (SETQ |$bpParenCount| (+ |$bpParenCount| 1)) (|bpNext|) (COND ((AND (APPLY |f| NIL) (|bpFirstTok|) (OR (|bpEqPeek| (QUOTE CPAREN)) (|bpParenTrap| |a|))) (SETQ |$bpParenCount| (- |$bpParenCount| 1)) (|bpNextToken|) (COND ((EQL |$bpCount| 0) T) (#0=(QUOTE T) (PROGN (SETQ |$inputStream| (APPEND (|bpAddTokens| |$bpCount|) |$inputStream|)) (|bpFirstToken|) (COND ((EQL |$bpParenCount| 0) (PROGN (|bpCancel|) T)) (#0# T)))))) ((|bpEqPeek| (QUOTE CPAREN)) (|bpPush| (|bfTuple| NIL)) (SETQ |$bpParenCount| (- |$bpParenCount| 1)) (|bpNextToken|) T) (#1=(QUOTE T) (|bpParenTrap| |a|)))) (#1# NIL))))))
(DEFUN |bpParenthesized| (|f|) (PROG (|a|) (DECLARE (SPECIAL |$stok|)) (RETURN (PROGN (SETQ |a| |$stok|) (COND ((|bpEqKey| (QUOTE OPAREN)) (COND ((AND (APPLY |f| NIL) (OR (|bpEqKey| (QUOTE CPAREN)) (|bpParenTrap| |a|))) T) ((|bpEqKey| (QUOTE CPAREN)) (|bpPush| (|bfTuple| NIL)) T) (#0=(QUOTE T) (|bpParenTrap| |a|)))) (#0# NIL))))))
(DEFUN |bpBracket| (|f|) (PROG (|a|) (DECLARE (SPECIAL |$stok|)) (RETURN (PROGN (SETQ |a| |$stok|) (COND ((|bpEqKey| (QUOTE OBRACK)) (COND ((AND (APPLY |f| NIL) (OR (|bpEqKey| (QUOTE CBRACK)) (|bpBrackTrap| |a|))) (|bpPush| (|bfBracket| (|bpPop1|)))) ((|bpEqKey| (QUOTE CBRACK)) (|bpPush| NIL)) (#0=(QUOTE T) (|bpBrackTrap| |a|)))) (#0# NIL))))))
(DEFUN |bpPileBracketed| (|f|) (PROG NIL (RETURN (COND ((|bpEqKey| (QUOTE SETTAB)) (COND ((|bpEqKey| (QUOTE BACKTAB)) T) ((AND (APPLY |f| NIL) (OR (|bpEqKey| (QUOTE BACKTAB)) (|bpPileTrap|))) (|bpPush| (|bfPile| (|bpPop1|)))) (#0=(QUOTE T) NIL))) (#0# NIL)))))
(DEFUN |bpListof| (|f| |str1| |g|) (PROG (|a|) (DECLARE (SPECIAL |$stack|)) (RETURN (COND ((APPLY |f| NIL) (COND ((AND (|bpEqKey| |str1|) (OR (APPLY |f| NIL) (|bpTrap|))) (SETQ |a| |$stack|) (SETQ |$stack| NIL) ((LAMBDA NIL (LOOP (COND ((NOT (AND (|bpEqKey| |str1|) (OR (APPLY |f| NIL) (|bpTrap|)))) (RETURN NIL)) ((QUOTE T) 0))))) (SETQ |$stack| (CONS (NREVERSE |$stack|) |a|)) (|bpPush| (FUNCALL |g| (CONS (|bpPop3|) (CONS (|bpPop2|) (|bpPop1|)))))) (#0=(QUOTE T) T))) (#0# NIL)))))
(DEFUN |bpListofFun| (|f| |h| |g|) (PROG (|a|) (DECLARE (SPECIAL |$stack|)) (RETURN (COND ((APPLY |f| NIL) (COND ((AND (APPLY |h| NIL) (OR (APPLY |f| NIL) (|bpTrap|))) (SETQ |a| |$stack|) (SETQ |$stack| NIL) ((LAMBDA NIL (LOOP (COND ((NOT (AND (APPLY |h| NIL) (OR (APPLY |f| NIL) (|bpTrap|)))) (RETURN NIL)) ((QUOTE T) 0))))) (SETQ |$stack| (CONS (NREVERSE |$stack|) |a|)) (|bpPush| (FUNCALL |g| (|bfListOf| (CONS (|bpPop3|) (CONS (|bpPop2|) (|bpPop1|))))))) (#0=(QUOTE T) T))) (#0# NIL)))))
(DEFUN |bpList| (|f| |str1| |g|) (PROG (|a|) (DECLARE (SPECIAL |$stack|)) (RETURN (COND ((APPLY |f| NIL) (COND ((AND (|bpEqKey| |str1|) (OR (APPLY |f| NIL) (|bpTrap|))) (SETQ |a| |$stack|) (SETQ |$stack| NIL) ((LAMBDA NIL (LOOP (COND ((NOT (AND (|bpEqKey| |str1|) (OR (APPLY |f| NIL) (|bpTrap|)))) (RETURN NIL)) ((QUOTE T) 0))))) (SETQ |$stack| (CONS (NREVERSE |$stack|) |a|)) (|bpPush| (FUNCALL |g| (CONS (|bpPop3|) (CONS (|bpPop2|) (|bpPop1|)))))) (#0=(QUOTE T) (|bpPush| (FUNCALL |g| (LIST (|bpPop1|))))))) (#0# (|bpPush| (FUNCALL |g| NIL)))))))
(DEFUN |bpOneOrMore| (|f|) (PROG (|a|) (DECLARE (SPECIAL |$stack|)) (RETURN (COND ((APPLY |f| NIL) (PROGN (SETQ |a| |$stack|) (SETQ |$stack| NIL) ((LAMBDA NIL (LOOP (COND ((NOT (APPLY |f| NIL)) (RETURN NIL)) ((QUOTE T) 0))))) (SETQ |$stack| (CONS (NREVERSE |$stack|) |a|)) (|bpPush| (CONS (|bpPop2|) (|bpPop1|))))) ((QUOTE T) NIL)))))
(DEFUN |bpAnyNo| (|s|) (PROG NIL (RETURN (PROGN ((LAMBDA NIL (LOOP (COND ((NOT (APPLY |s| NIL)) (RETURN NIL)) ((QUOTE T) 0))))) T))))
(DEFUN |bpAndOr| (|keyword| |p| |f|) (PROG NIL (RETURN (AND (|bpEqKey| |keyword|) (OR (APPLY |p| NIL) (|bpTrap|)) (|bpPush| (FUNCALL |f| (|bpPop1|)))))))
(DEFUN |bpConditional| (|f|) (PROG NIL (RETURN (COND ((AND (|bpEqKey| (QUOTE IF)) (OR (|bpWhere|) (|bpTrap|)) (OR (|bpEqKey| (QUOTE BACKSET)) T)) (COND ((|bpEqKey| (QUOTE SETTAB)) (COND ((|bpEqKey| (QUOTE THEN)) (AND (OR (APPLY |f| NIL) (|bpTrap|)) (|bpElse| |f|) (|bpEqKey| (QUOTE BACKTAB)))) (#0=(QUOTE T) (|bpMissing| (QUOTE THEN))))) ((|bpEqKey| (QUOTE THEN)) (AND (OR (APPLY |f| NIL) (|bpTrap|)) (|bpElse| |f|))) (#0# (|bpMissing| (QUOTE |then|))))) (#0# NIL)))))
(DEFUN |bpElse| (|f|) (PROG (|a|) (RETURN (PROGN (SETQ |a| (|bpState|)) (COND ((|bpBacksetElse|) (AND (OR (APPLY |f| NIL) (|bpTrap|)) (|bpPush| (|bfIf| (|bpPop3|) (|bpPop2|) (|bpPop1|))))) ((QUOTE T) (|bpRestore| |a|) (|bpPush| (|bfIfThenOnly| (|bpPop2|) (|bpPop1|)))))))))
(DEFUN |bpBacksetElse| NIL (PROG NIL (RETURN (COND ((|bpEqKey| (QUOTE BACKSET)) (|bpEqKey| (QUOTE ELSE))) ((QUOTE T) (|bpEqKey| (QUOTE ELSE)))))))
(DEFUN |bpEqPeek| (|s|) (PROG NIL (DECLARE (SPECIAL |$ttok| |$stok|)) (RETURN (AND (EQCAR |$stok| (QUOTE KEY)) (EQ |s| |$ttok|)))))
(DEFUN |bpEqKey| (|s|) (PROG NIL (DECLARE (SPECIAL |$ttok| |$stok|)) (RETURN (AND (EQCAR |$stok| (QUOTE KEY)) (EQ |s| |$ttok|) (|bpNext|)))))
(DEFUN |bpEqKeyNextTok| (|s|) (PROG NIL (DECLARE (SPECIAL |$ttok| |$stok|)) (RETURN (AND (EQCAR |$stok| (QUOTE KEY)) (EQ |s| |$ttok|) (|bpNextToken|)))))
(DEFUN |bpPileTrap| NIL (PROG NIL (RETURN (|bpMissing| (QUOTE BACKTAB)))))
(DEFUN |bpBrackTrap| (|x|) (PROG NIL (RETURN (|bpMissingMate| (QUOTE ]) |x|))))
(DEFUN |bpParenTrap| (|x|) (PROG NIL (RETURN (|bpMissingMate| (QUOTE |)|) |x|))))
(DEFUN |bpMissingMate| (|close| |open|) (PROG NIL (RETURN (PROGN (|bpSpecificErrorAtToken| |open| "possibly missing mate") (|bpMissing| |close|)))))
(DEFUN |bpMissing| (|s|) (PROG NIL (RETURN (PROGN (|bpSpecificErrorHere| (CONCAT (PNAME |s|) " possibly missing")) (THROW (QUOTE TRAPPOINT) (QUOTE TRAPPED))))))
(DEFUN |bpCompMissing| (|s|) (PROG NIL (RETURN (OR (|bpEqKey| |s|) (|bpMissing| |s|)))))
(DEFUN |bpTrap| NIL (PROG NIL (RETURN (PROGN (|bpGeneralErrorHere|) (THROW (QUOTE TRAPPOINT) (QUOTE TRAPPED))))))
(DEFUN |bpRecoverTrap| NIL (PROG (|pos2| |pos1|) (DECLARE (SPECIAL |$stok|)) (RETURN (PROGN (|bpFirstToken|) (SETQ |pos1| (|shoeTokPosn| |$stok|)) (|bpMoveTo| 0) (SETQ |pos2| (|shoeTokPosn| |$stok|)) (|bpIgnoredFromTo| |pos1| |pos2|) (|bpPush| (LIST (LIST "pile syntax error")))))))
(DEFUN |bpListAndRecover| (|f|) (PROG (|found| |c| |done| |b| |a|) (DECLARE (SPECIAL |$inputStream| |$stack|)) (RETURN (PROGN (SETQ |a| |$stack|) (SETQ |b| NIL) (SETQ |$stack| NIL) (SETQ |done| NIL) (SETQ |c| |$inputStream|) ((LAMBDA NIL (LOOP (COND (|done| (RETURN NIL)) ((QUOTE T) (PROGN (SETQ |found| (CATCH (QUOTE TRAPPOINT) (APPLY |f| NIL))) (COND ((EQ |found| (QUOTE TRAPPED)) (SETQ |$inputStream| |c|) (|bpRecoverTrap|)) ((NULL |found|) (SETQ |$inputStream| |c|) (|bpGeneralErrorHere|) (|bpRecoverTrap|))) (COND ((|bpEqKey| (QUOTE BACKSET)) (SETQ |c| |$inputStream|)) ((OR (|bpEqPeek| (QUOTE BACKTAB)) (NULL |$inputStream|)) (SETQ |done| T)) (#0=(QUOTE T) (SETQ |$inputStream| |c|) (|bpGeneralErrorHere|) (|bpRecoverTrap|) (COND ((OR (|bpEqPeek| (QUOTE BACKTAB)) (NULL |$inputStream|)) (SETQ |done| T)) (#0# (|bpNext|) (SETQ |c| |$inputStream|))))) (SETQ |b| (CONS (|bpPop1|) |b|)))))))) (SETQ |$stack| |a|) (|bpPush| (NREVERSE |b|))))))
(DEFUN |bpMoveTo| (|n|) (PROG NIL (DECLARE (SPECIAL |$bpParenCount| |$bpCount| |$inputStream|)) (RETURN (COND ((NULL |$inputStream|) T) ((|bpEqPeek| (QUOTE BACKTAB)) (COND ((EQL |n| 0) T) (#0=(QUOTE T) (PROGN (|bpNextToken|) (SETQ |$bpCount| (- |$bpCount| 1)) (|bpMoveTo| (- |n| 1)))))) ((|bpEqPeek| (QUOTE BACKSET)) (COND ((EQL |n| 0) T) (#0# (PROGN (|bpNextToken|) (|bpMoveTo| |n|))))) ((|bpEqPeek| (QUOTE SETTAB)) (PROGN (|bpNextToken|) (|bpMoveTo| (+ |n| 1)))) ((|bpEqPeek| (QUOTE OPAREN)) (PROGN (|bpNextToken|) (SETQ |$bpParenCount| (+ |$bpParenCount| 1)) (|bpMoveTo| |n|))) ((|bpEqPeek| (QUOTE CPAREN)) (PROGN (|bpNextToken|) (SETQ |$bpParenCount| (- |$bpParenCount| 1)) (|bpMoveTo| |n|))) (#0# (PROGN (|bpNextToken|) (|bpMoveTo| |n|)))))))
(DEFUN |bpSpecificErrorAtToken| (|tok| |key|) (PROG (|a|) (RETURN (PROGN (SETQ |a| (|shoeTokPosn| |tok|)) (|SoftShoeError| |a| |key|)))))
(DEFUN |bpGeneralErrorHere| NIL (PROG NIL (RETURN (|bpSpecificErrorHere| "syntax error"))))
(DEFUN |bpSpecificErrorHere| (|key|) (PROG NIL (DECLARE (SPECIAL |$stok|)) (RETURN (|bpSpecificErrorAtToken| |$stok| |key|))))
(DEFUN |bpName| NIL (PROG NIL (DECLARE (SPECIAL |$stok|)) (RETURN (COND ((EQCAR |$stok| (QUOTE ID)) (|bpPushId|) (|bpNext|)) ((QUOTE T) NIL)))))
(DEFUN |bpConstTok| NIL (PROG NIL (DECLARE (SPECIAL |$ttok| |$stok|)) (RETURN (COND ((MEMQ (|shoeTokType| |$stok|) (QUOTE (INTEGER FLOAT))) (PROGN (|bpPush| |$ttok|) (|bpNext|))) ((EQCAR |$stok| (QUOTE LISP)) (AND (|bpPush| (|bfReadLisp| |$ttok|)) (|bpNext|))) ((EQCAR |$stok| (QUOTE LISPEXP)) (AND (|bpPush| |$ttok|) (|bpNext|))) ((EQCAR |$stok| (QUOTE LINE)) (AND (|bpPush| (LIST (QUOTE +LINE) |$ttok|)) (|bpNext|))) ((|bpEqPeek| (QUOTE QUOTE)) (PROGN (|bpNext|) (AND (OR (|bpSexp|) (|bpTrap|)) (|bpPush| (|bfSymbol| (|bpPop1|)))))) ((QUOTE T) (|bpString|))))))
(DEFUN |bpCancel| NIL (PROG (|a|) (RETURN (PROGN (SETQ |a| (|bpState|)) (COND ((|bpEqKeyNextTok| (QUOTE SETTAB)) (COND ((|bpCancel|) (COND ((|bpEqKeyNextTok| (QUOTE BACKTAB)) T) (#0=(QUOTE T) (|bpRestore| |a|) NIL))) ((|bpEqKeyNextTok| (QUOTE BACKTAB)) T) (#0# (|bpRestore| |a|) NIL))) (#0# NIL))))))
(DEFUN |bpAddTokens| (|n|) (PROG NIL (DECLARE (SPECIAL |$stok|)) (RETURN (COND ((EQL |n| 0) NIL) ((< 0 |n|) (CONS (|shoeTokConstruct| (QUOTE KEY) (QUOTE SETTAB) (|shoeTokPosn| |$stok|)) (|bpAddTokens| (- |n| 1)))) ((QUOTE T) (CONS (|shoeTokConstruct| (QUOTE KEY) (QUOTE BACKTAB) (|shoeTokPosn| |$stok|)) (|bpAddTokens| (+ |n| 1))))))))
(DEFUN |bpExceptions| NIL (PROG NIL (RETURN (OR (|bpEqPeek| (QUOTE DOT)) (|bpEqPeek| (QUOTE QUOTE)) (|bpEqPeek| (QUOTE OPAREN)) (|bpEqPeek| (QUOTE CPAREN)) (|bpEqPeek| (QUOTE SETTAB)) (|bpEqPeek| (QUOTE BACKTAB)) (|bpEqPeek| (QUOTE BACKSET))))))
(DEFUN |bpSexpKey| NIL (PROG (|a|) (DECLARE (SPECIAL |$ttok| |$stok|)) (RETURN (COND ((AND (EQCAR |$stok| (QUOTE KEY)) (NULL (|bpExceptions|))) (PROGN (SETQ |a| (GET |$ttok| (QUOTE SHOEINF))) (COND ((NULL |a|) (AND (|bpPush| |$ttok|) (|bpNext|))) (#0=(QUOTE T) (AND (|bpPush| |a|) (|bpNext|)))))) (#0# NIL)))))
(DEFUN |bpAnyId| NIL (PROG NIL (DECLARE (SPECIAL |$ttok| |$stok|)) (RETURN (OR (AND (|bpEqKey| (QUOTE MINUS)) (OR (EQCAR |$stok| (QUOTE INTEGER)) (|bpTrap|)) (|bpPush| (- |$ttok|)) (|bpNext|)) (|bpSexpKey|) (AND (MEMQ (|shoeTokType| |$stok|) (QUOTE (ID INTEGER STRING FLOAT))) (|bpPush| |$ttok|) (|bpNext|))))))
(DEFUN |bpSexp| NIL (PROG NIL (RETURN (OR (|bpAnyId|) (AND (|bpEqKey| (QUOTE QUOTE)) (OR (|bpSexp|) (|bpTrap|)) (|bpPush| (|bfSymbol| (|bpPop1|)))) (|bpIndentParenthesized| (FUNCTION |bpSexp1|))))))
(DEFUN |bpSexp1| NIL (PROG NIL (RETURN (OR (AND (|bpFirstTok|) (|bpSexp|) (OR (AND (|bpEqKey| (QUOTE DOT)) (|bpSexp|) (|bpPush| (CONS (|bpPop2|) (|bpPop1|)))) (AND (|bpSexp1|) (|bpPush| (CONS (|bpPop2|) (|bpPop1|)))))) (|bpPush| NIL)))))
(DEFUN |bpPrimary1| NIL (PROG NIL (RETURN (OR (|bpName|) (|bpDot|) (|bpConstTok|) (|bpConstruct|) (|bpCase|) (|bpStruct|) (|bpPDefinition|) (|bpBPileDefinition|)))))
(DEFUN |bpPrimary| NIL (PROG NIL (RETURN (AND (|bpFirstTok|) (OR (|bpPrimary1|) (|bpPrefixOperator|))))))
(DEFUN |bpDot| NIL (PROG NIL (RETURN (AND (|bpEqKey| (QUOTE DOT)) (|bpPush| (|bfDot|))))))
(DEFUN |bpPrefixOperator| NIL (PROG NIL (DECLARE (SPECIAL |$ttok| |$stok|)) (RETURN (AND (EQCAR |$stok| (QUOTE KEY)) (GET |$ttok| (QUOTE SHOEPRE)) (|bpPushId|) (|bpNext|)))))
(DEFUN |bpInfixOperator| NIL (PROG NIL (DECLARE (SPECIAL |$ttok| |$stok|)) (RETURN (AND (EQCAR |$stok| (QUOTE KEY)) (GET |$ttok| (QUOTE SHOEINF)) (|bpPushId|) (|bpNext|)))))
(DEFUN |bpSelector| NIL (PROG NIL (RETURN (AND (|bpEqKey| (QUOTE DOT)) (OR (AND (|bpPrimary|) (|bpPush| (|bfElt| (|bpPop2|) (|bpPop1|)))) (|bpPush| (|bfSuffixDot| (|bpPop1|))))))))
(DEFUN |bpOperator| NIL (PROG NIL (RETURN (AND (|bpPrimary|) (|bpAnyNo| (FUNCTION |bpSelector|))))))
(DEFUN |bpApplication| NIL (PROG NIL (RETURN (AND (|bpPrimary|) (|bpAnyNo| (FUNCTION |bpSelector|)) (OR (AND (|bpApplication|) (|bpPush| (|bfApplication| (|bpPop2|) (|bpPop1|)))) T)))))
(DEFUN |bpTagged| NIL (PROG NIL (RETURN (AND (|bpApplication|) (OR (AND (|bpEqKey| (QUOTE COLON)) (OR (|bpApplication|) (|bpTrap|)) (|bpPush| (|bfTagged| (|bpPop2|) (|bpPop1|)))) T)))))
(DEFUN |bpExpt| NIL (PROG NIL (RETURN (|bpRightAssoc| (QUOTE (POWER)) (FUNCTION |bpTagged|)))))
(DEFUN |bpInfKey| (|s|) (PROG NIL (DECLARE (SPECIAL |$ttok| |$stok|)) (RETURN (AND (EQCAR |$stok| (QUOTE KEY)) (MEMBER |$ttok| |s|) (|bpPushId|) (|bpNext|)))))
(DEFUN |bpInfGeneric| (|s|) (PROG NIL (RETURN (AND (|bpInfKey| |s|) (OR (|bpEqKey| (QUOTE BACKSET)) T)))))
(DEFUN |bpRightAssoc| (|o| |p|) (PROG (|a|) (RETURN (PROGN (SETQ |a| (|bpState|)) (COND ((APPLY |p| NIL) ((LAMBDA NIL (LOOP (COND ((NOT (AND (|bpInfGeneric| |o|) (OR (|bpRightAssoc| |o| |p|) (|bpTrap|)))) (RETURN NIL)) ((QUOTE T) (|bpPush| (|bfInfApplication| (|bpPop2|) (|bpPop2|) (|bpPop1|)))))))) T) ((QUOTE T) (|bpRestore| |a|) NIL))))))
(DEFUN |bpLeftAssoc| (|operations| |parser|) (PROG NIL (RETURN (COND ((APPLY |parser| NIL) ((LAMBDA NIL (LOOP (COND ((NOT (AND (|bpInfGeneric| |operations|) (OR (APPLY |parser| NIL) (|bpTrap|)))) (RETURN NIL)) ((QUOTE T) (|bpPush| (|bfInfApplication| (|bpPop2|) (|bpPop2|) (|bpPop1|)))))))) T) ((QUOTE T) NIL)))))
(DEFUN |bpString| NIL (PROG NIL (DECLARE (SPECIAL |$ttok| |$stok|)) (RETURN (AND (EQ (|shoeTokType| |$stok|) (QUOTE STRING)) (|bpPush| (LIST (QUOTE QUOTE) (INTERN |$ttok|))) (|bpNext|)))))
(DEFUN |bpThetaName| NIL (PROG NIL (DECLARE (SPECIAL |$ttok| |$stok|)) (RETURN (COND ((AND (EQCAR |$stok| (QUOTE ID)) (GET |$ttok| (QUOTE SHOETHETA))) (|bpPushId|) (|bpNext|)) ((QUOTE T) NIL)))))
(DEFUN |bpReduceOperator| NIL (PROG NIL (RETURN (OR (|bpInfixOperator|) (|bpString|) (|bpThetaName|)))))
(DEFUN |bpReduce| NIL (PROG (|a|) (RETURN (PROGN (SETQ |a| (|bpState|)) (COND ((AND (|bpReduceOperator|) (|bpEqKey| (QUOTE SLASH))) (COND ((|bpEqPeek| (QUOTE OBRACK)) (AND (OR (|bpDConstruct|) (|bpTrap|)) (|bpPush| (|bfReduceCollect| (|bpPop2|) (|bpPop1|))))) ((QUOTE T) (AND (OR (|bpApplication|) (|bpTrap|)) (|bpPush| (|bfReduce| (|bpPop2|) (|bpPop1|))))))) ((QUOTE T) (|bpRestore| |a|) NIL))))))
(DEFUN |bpTimes| NIL (PROG NIL (RETURN (OR (|bpReduce|) (|bpLeftAssoc| (QUOTE (TIMES SLASH)) (FUNCTION |bpExpt|))))))
(DEFUN |bpMinus| NIL (PROG NIL (RETURN (OR (AND (|bpInfGeneric| (QUOTE (MINUS))) (OR (|bpTimes|) (|bpTrap|)) (|bpPush| (|bfApplication| (|bpPop2|) (|bpPop1|)))) (|bpTimes|)))))
(DEFUN |bpArith| NIL (PROG NIL (RETURN (|bpLeftAssoc| (QUOTE (PLUS MINUS)) (FUNCTION |bpMinus|)))))
(DEFUN |bpIs| NIL (PROG NIL (RETURN (AND (|bpArith|) (OR (AND (|bpInfKey| (QUOTE (IS ISNT))) (OR (|bpPattern|) (|bpTrap|)) (|bpPush| (|bfISApplication| (|bpPop2|) (|bpPop2|) (|bpPop1|)))) T)))))
(DEFUN |bpBracketConstruct| (|f|) (PROG NIL (RETURN (AND (|bpBracket| |f|) (|bpPush| (|bfConstruct| (|bpPop1|)))))))
(DEFUN |bpCompare| NIL (PROG NIL (RETURN (AND (|bpIs|) (OR (AND (|bpInfKey| (QUOTE (SHOEEQ NE LT LE GT GE IN))) (OR (|bpIs|) (|bpTrap|)) (|bpPush| (|bfInfApplication| (|bpPop2|) (|bpPop2|) (|bpPop1|)))) T)))))
(DEFUN |bpAnd| NIL (PROG NIL (RETURN (|bpLeftAssoc| (QUOTE (AND)) (FUNCTION |bpCompare|)))))
(DEFUN |bpReturn| NIL (PROG NIL (RETURN (OR (AND (|bpEqKey| (QUOTE RETURN)) (OR (|bpAnd|) (|bpTrap|)) (|bpPush| (|bfReturnNoName| (|bpPop1|)))) (|bpAnd|)))))
(DEFUN |bpLogical| NIL (PROG NIL (RETURN (|bpLeftAssoc| (QUOTE (OR)) (FUNCTION |bpReturn|)))))
(DEFUN |bpExpression| NIL (PROG NIL (RETURN (OR (AND (|bpEqKey| (QUOTE COLON)) (OR (AND (|bpLogical|) (|bpPush| (|bfApplication| (QUOTE COLON) (|bpPop1|)))) (|bpTrap|))) (|bpLogical|)))))
(DEFUN |bpStatement| NIL (PROG NIL (RETURN (OR (|bpConditional| (FUNCTION |bpWhere|)) (|bpLoop|) (|bpExpression|)))))
(DEFUN |bpLoop| NIL (PROG NIL (RETURN (OR (AND (|bpIterators|) (|bpCompMissing| (QUOTE REPEAT)) (OR (|bpWhere|) (|bpTrap|)) (|bpPush| (|bfLp| (|bpPop2|) (|bpPop1|)))) (AND (|bpEqKey| (QUOTE REPEAT)) (OR (|bpLogical|) (|bpTrap|)) (|bpPush| (|bfLoop1| (|bpPop1|))))))))
(DEFUN |bpSuchThat| NIL (PROG NIL (RETURN (|bpAndOr| (QUOTE BAR) (FUNCTION |bpWhere|) (FUNCTION |bfSuchthat|)))))
(DEFUN |bpWhile| NIL (PROG NIL (RETURN (|bpAndOr| (QUOTE WHILE) (FUNCTION |bpLogical|) (FUNCTION |bfWhile|)))))
(DEFUN |bpUntil| NIL (PROG NIL (RETURN (|bpAndOr| (QUOTE UNTIL) (FUNCTION |bpLogical|) (FUNCTION |bfUntil|)))))
(DEFUN |bpForIn| NIL (PROG NIL (RETURN (AND (|bpEqKey| (QUOTE FOR)) (OR (|bpVariable|) (|bpTrap|)) (|bpCompMissing| (QUOTE IN)) (OR (AND (OR (|bpSeg|) (|bpTrap|)) (|bpEqKey| (QUOTE BY)) (OR (|bpArith|) (|bpTrap|)) (|bpPush| (|bfForInBy| (|bpPop3|) (|bpPop2|) (|bpPop1|)))) (|bpPush| (|bfForin| (|bpPop2|) (|bpPop1|))))))))
(DEFUN |bpSeg| NIL (PROG NIL (RETURN (AND (|bpArith|) (OR (AND (|bpEqKey| (QUOTE SEG)) (OR (AND (|bpArith|) (|bpPush| (|bfSegment2| (|bpPop2|) (|bpPop1|)))) (|bpPush| (|bfSegment1| (|bpPop1|))))) T)))))
(DEFUN |bpIterator| NIL (PROG NIL (RETURN (OR (|bpForIn|) (|bpSuchThat|) (|bpWhile|) (|bpUntil|)))))
(DEFUN |bpIteratorList| NIL (PROG NIL (RETURN (AND (|bpOneOrMore| (FUNCTION |bpIterator|)) (|bpPush| (|bfIterators| (|bpPop1|)))))))
(DEFUN |bpCrossBackSet| NIL (PROG NIL (RETURN (AND (|bpEqKey| (QUOTE CROSS)) (OR (|bpEqKey| (QUOTE BACKSET)) T)))))
(DEFUN |bpIterators| NIL (PROG NIL (RETURN (|bpListofFun| (FUNCTION |bpIteratorList|) (FUNCTION |bpCrossBackSet|) (FUNCTION |bfCross|)))))
(DEFUN |bpAssign| NIL (PROG (|a|) (RETURN (PROGN (SETQ |a| (|bpState|)) (COND ((|bpStatement|) (COND ((|bpEqPeek| (QUOTE BEC)) (|bpRestore| |a|) (OR (|bpAssignment|) (|bpTrap|))) (#0=(QUOTE T) T))) (#0# (|bpRestore| |a|) NIL))))))
(DEFUN |bpAssignment| NIL (PROG NIL (RETURN (AND (|bpAssignVariable|) (|bpEqKey| (QUOTE BEC)) (OR (|bpAssign|) (|bpTrap|)) (|bpPush| (|bfAssign| (|bpPop2|) (|bpPop1|)))))))
(DEFUN |bpExit| NIL (PROG NIL (RETURN (AND (|bpAssign|) (OR (AND (|bpEqKey| (QUOTE EXIT)) (OR (|bpWhere|) (|bpTrap|)) (|bpPush| (|bfExit| (|bpPop2|) (|bpPop1|)))) T)))))
(DEFUN |bpDefinition| NIL (PROG (|a|) (RETURN (PROGN (SETQ |a| (|bpState|)) (COND ((|bpExit|) (COND ((|bpEqPeek| (QUOTE DEF)) (PROGN (|bpRestore| |a|) (|bpDef|))) ((|bpEqPeek| (QUOTE MDEF)) (PROGN (|bpRestore| |a|) (|bpMdef|))) (#0=(QUOTE T) T))) (#0# (PROGN (|bpRestore| |a|) NIL)))))))
(DEFUN |bpStoreName| NIL (PROG NIL (DECLARE (SPECIAL |$typings| |$wheredefs| |$op| |$stack|)) (RETURN (PROGN (SETQ |$op| (CAR |$stack|)) (SETQ |$wheredefs| NIL) (SETQ |$typings| NIL) T))))
(DEFUN |bpDef| NIL (PROG NIL (RETURN (AND (|bpName|) (|bpStoreName|) (|bpDefTail|) (|bpPush| (|bfCompDef| (|bpPop1|)))))))
(DEFUN |bpDDef| NIL (PROG NIL (RETURN (AND (|bpName|) (|bpDefTail|)))))
(DEFUN |bpDefTail| NIL (PROG NIL (RETURN (OR (AND (|bpEqKey| (QUOTE DEF)) (OR (|bpWhere|) (|bpTrap|)) (|bpPush| (|bfDefinition1| (|bpPop2|) (|bpPop1|)))) (AND (|bpVariable|) (|bpEqKey| (QUOTE DEF)) (OR (|bpWhere|) (|bpTrap|)) (|bpPush| (|bfDefinition2| (|bpPop3|) (|bpPop2|) (|bpPop1|))))))))
(DEFUN |bpMDefTail| NIL (PROG NIL (RETURN (AND (OR (|bpVariable|) (|bpTrap|)) (|bpEqKey| (QUOTE MDEF)) (OR (|bpWhere|) (|bpTrap|)) (|bpPush| (|bfMDefinition2| (|bpPop3|) (|bpPop2|) (|bpPop1|)))))))
(DEFUN |bpMdef| NIL (PROG NIL (RETURN (AND (|bpName|) (|bpStoreName|) (|bpMDefTail|)))))
(DEFUN |bpWhere| NIL (PROG NIL (RETURN (AND (|bpDefinition|) (OR (AND (|bpEqKey| (QUOTE WHERE)) (OR (|bpDefinitionItem|) (|bpTrap|)) (|bpPush| (|bfWhere| (|bpPop1|) (|bpPop1|)))) T)))))
(DEFUN |bpDefinitionItem| NIL (PROG (|a|) (RETURN (PROGN (SETQ |a| (|bpState|)) (COND ((|bpDDef|) T) (#0=(QUOTE T) (|bpRestore| |a|) (COND ((|bpBDefinitionPileItems|) T) (#0# (|bpRestore| |a|) (COND ((|bpPDefinitionItems|) T) (#0# (|bpRestore| |a|) (|bpWhere|)))))))))))
(DEFUN |bpDefinitionPileItems| NIL (PROG NIL (RETURN (AND (|bpListAndRecover| (FUNCTION |bpDefinitionItem|)) (|bpPush| (|bfDefSequence| (|bpPop1|)))))))
(DEFUN |bpBDefinitionPileItems| NIL (PROG NIL (RETURN (|bpPileBracketed| (FUNCTION |bpDefinitionPileItems|)))))
(DEFUN |bpSemiColonDefinition| NIL (PROG NIL (RETURN (|bpSemiListing| (FUNCTION |bpDefinitionItem|) (FUNCTION |bfDefSequence|)))))
(DEFUN |bpPDefinitionItems| NIL (PROG NIL (RETURN (|bpParenthesized| (FUNCTION |bpSemiColonDefinition|)))))
(DEFUN |bpComma| NIL (PROG NIL (RETURN (|bpTuple| (FUNCTION |bpWhere|)))))
(DEFUN |bpTuple| (|p|) (PROG NIL (RETURN (|bpListofFun| |p| (FUNCTION |bpCommaBackSet|) (FUNCTION |bfTuple|)))))
(DEFUN |bpCommaBackSet| NIL (PROG NIL (RETURN (AND (|bpEqKey| (QUOTE COMMA)) (OR (|bpEqKey| (QUOTE BACKSET)) T)))))
(DEFUN |bpSemiColon| NIL (PROG NIL (RETURN (|bpSemiListing| (FUNCTION |bpComma|) (FUNCTION |bfSequence|)))))
(DEFUN |bpSemiListing| (|p| |f|) (PROG NIL (RETURN (|bpListofFun| |p| (FUNCTION |bpSemiBackSet|) |f|))))
(DEFUN |bpSemiBackSet| NIL (PROG NIL (RETURN (AND (|bpEqKey| (QUOTE SEMICOLON)) (OR (|bpEqKey| (QUOTE BACKSET)) T)))))
(DEFUN |bpPDefinition| NIL (PROG NIL (RETURN (|bpIndentParenthesized| (FUNCTION |bpSemiColon|)))))
(DEFUN |bpPileItems| NIL (PROG NIL (RETURN (AND (|bpListAndRecover| (FUNCTION |bpSemiColon|)) (|bpPush| (|bfSequence| (|bpPop1|)))))))
(DEFUN |bpBPileDefinition| NIL (PROG NIL (RETURN (|bpPileBracketed| (FUNCTION |bpPileItems|)))))
(DEFUN |bpIteratorTail| NIL (PROG NIL (RETURN (AND (OR (|bpEqKey| (QUOTE REPEAT)) T) (|bpIterators|)))))
(DEFUN |bpConstruct| NIL (PROG NIL (RETURN (|bpBracket| (FUNCTION |bpConstruction|)))))
(DEFUN |bpConstruction| NIL (PROG NIL (RETURN (AND (|bpComma|) (OR (AND (|bpIteratorTail|) (|bpPush| (|bfCollect| (|bpPop2|) (|bpPop1|)))) (|bpPush| (|bfTupleConstruct| (|bpPop1|))))))))
(DEFUN |bpDConstruct| NIL (PROG NIL (RETURN (|bpBracket| (FUNCTION |bpDConstruction|)))))
(DEFUN |bpDConstruction| NIL (PROG NIL (RETURN (AND (|bpComma|) (OR (AND (|bpIteratorTail|) (|bpPush| (|bfDCollect| (|bpPop2|) (|bpPop1|)))) (|bpPush| (|bfDTuple| (|bpPop1|))))))))
(DEFUN |bpPattern| NIL (PROG NIL (RETURN (OR (|bpBracketConstruct| (FUNCTION |bpPatternL|)) (|bpName|) (|bpConstTok|)))))
(DEFUN |bpEqual| NIL (PROG NIL (RETURN (AND (|bpEqKey| (QUOTE SHOEEQ)) (OR (|bpApplication|) (|bpConstTok|) (|bpTrap|)) (|bpPush| (|bfEqual| (|bpPop1|)))))))
(DEFUN |bpRegularPatternItem| NIL (PROG NIL (RETURN (OR (|bpEqual|) (|bpConstTok|) (|bpDot|) (AND (|bpName|) (OR (AND (|bpEqKey| (QUOTE BEC)) (OR (|bpPattern|) (|bpTrap|)) (|bpPush| (|bfAssign| (|bpPop2|) (|bpPop1|)))) T)) (|bpBracketConstruct| (FUNCTION |bpPatternL|))))))
(DEFUN |bpRegularPatternItemL| NIL (PROG NIL (RETURN (AND (|bpRegularPatternItem|) (|bpPush| (LIST (|bpPop1|)))))))
(DEFUN |bpRegularList| NIL (PROG NIL (RETURN (|bpListof| (FUNCTION |bpRegularPatternItemL|) (QUOTE COMMA) (FUNCTION |bfAppend|)))))
(DEFUN |bpPatternColon| NIL (PROG NIL (RETURN (AND (|bpEqKey| (QUOTE COLON)) (OR (|bpRegularPatternItem|) (|bpTrap|)) (|bpPush| (LIST (|bfColon| (|bpPop1|))))))))
(DEFUN |bpPatternL| NIL (PROG NIL (RETURN (AND (|bpPatternList|) (|bpPush| (|bfTuple| (|bpPop1|)))))))
(DEFUN |bpPatternList| NIL (PROG NIL (RETURN (COND ((|bpRegularPatternItemL|) ((LAMBDA NIL (LOOP (COND ((NOT (AND (|bpEqKey| (QUOTE COMMA)) (OR (|bpRegularPatternItemL|) (PROGN (OR (AND (|bpPatternTail|) (|bpPush| (APPEND (|bpPop2|) (|bpPop1|)))) (|bpTrap|)) NIL)))) (RETURN NIL)) ((QUOTE T) (|bpPush| (APPEND (|bpPop2|) (|bpPop1|)))))))) T) ((QUOTE T) (|bpPatternTail|))))))
(DEFUN |bpPatternTail| NIL (PROG NIL (RETURN (AND (|bpPatternColon|) (OR (AND (|bpEqKey| (QUOTE COMMA)) (OR (|bpRegularList|) (|bpTrap|)) (|bpPush| (APPEND (|bpPop2|) (|bpPop1|)))) T)))))
(DEFUN |bpRegularBVItem| NIL (PROG NIL (RETURN (OR (|bpBVString|) (|bpConstTok|) (AND (|bpName|) (OR (AND (|bpEqKey| (QUOTE BEC)) (OR (|bpPattern|) (|bpTrap|)) (|bpPush| (|bfAssign| (|bpPop2|) (|bpPop1|)))) (AND (|bpEqKey| (QUOTE IS)) (OR (|bpPattern|) (|bpTrap|)) (|bpPush| (|bfAssign| (|bpPop2|) (|bpPop1|)))) T)) (|bpBracketConstruct| (FUNCTION |bpPatternL|))))))
(DEFUN |bpBVString| NIL (PROG NIL (DECLARE (SPECIAL |$ttok| |$stok|)) (RETURN (AND (EQ (|shoeTokType| |$stok|) (QUOTE STRING)) (|bpPush| (LIST (QUOTE BVQUOTE) (INTERN |$ttok|))) (|bpNext|)))))
(DEFUN |bpRegularBVItemL| NIL (PROG NIL (RETURN (AND (|bpRegularBVItem|) (|bpPush| (LIST (|bpPop1|)))))))
(DEFUN |bpColonName| NIL (PROG NIL (RETURN (AND (|bpEqKey| (QUOTE COLON)) (OR (|bpName|) (|bpBVString|) (|bpTrap|))))))
(DEFUN |bpBoundVariablelist| NIL (PROG NIL (RETURN (COND ((|bpRegularBVItemL|) ((LAMBDA NIL (LOOP (COND ((NOT (AND (|bpEqKey| (QUOTE COMMA)) (OR (|bpRegularBVItemL|) (PROGN (OR (AND (|bpColonName|) (|bpPush| (|bfColonAppend| (|bpPop2|) (|bpPop1|)))) (|bpTrap|)) NIL)))) (RETURN NIL)) ((QUOTE T) (|bpPush| (APPEND (|bpPop2|) (|bpPop1|)))))))) T) ((QUOTE T) (AND (|bpColonName|) (|bpPush| (|bfColonAppend| NIL (|bpPop1|)))))))))
(DEFUN |bpVariable| NIL (PROG NIL (RETURN (OR (AND (|bpParenthesized| (FUNCTION |bpBoundVariablelist|)) (|bpPush| (|bfTupleIf| (|bpPop1|)))) (|bpBracketConstruct| (FUNCTION |bpPatternL|)) (|bpName|) (|bpConstTok|)))))
(DEFUN |bpAssignVariable| NIL (PROG NIL (RETURN (OR (|bpBracketConstruct| (FUNCTION |bpPatternL|)) (|bpAssignLHS|)))))
(DEFUN |bpAssignLHS| NIL (PROG NIL (RETURN (AND (|bpName|) (OR (AND (|bpEqKey| (QUOTE COLON)) (OR (|bpApplication|) (|bpTrap|)) (|bpPush| (|bfLocal| (|bpPop2|) (|bpPop1|)))) (AND (|bpEqKey| (QUOTE DOT)) (|bpList| (FUNCTION |bpPrimary|) (QUOTE DOT) (FUNCTION |bfListOf|)) (|bpChecknull|) (|bpPush| (|bfTuple| (CONS (|bpPop2|) (|bpPop1|))))) T)))))
(DEFUN |bpChecknull| NIL (PROG (|a|) (RETURN (PROGN (SETQ |a| (|bpPop1|)) (COND ((NULL |a|) (|bpTrap|)) ((QUOTE T) (|bpPush| |a|)))))))
